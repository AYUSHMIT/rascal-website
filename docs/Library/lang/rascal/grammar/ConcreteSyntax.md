---
title: "module lang::rascal::grammar::ConcreteSyntax"
---

#### Usage

`import lang::rascal::grammar::ConcreteSyntax;`

  This module provides functionality for merging the Rascal grammar and arbitrary user-defined grammars

## function addHoles {#lang-rascal-grammar-ConcreteSyntax-addHoles}

* ``Grammar addHoles(Grammar object)``

## function holes {#lang-rascal-grammar-ConcreteSyntax-holes}

* ``set[Production] holes(Grammar object)``

  For every non-terminal in the grammar we create a rule that can recognize its hole syntax. Each hole
  is specific for a non-terminal (using its name as a literal), such that no ambiguity can arise. When parsing
  a fragment, the Rascal evaluator will generate a string that matches this generated syntax. It does so based on
  knowing the type of the variable, which is either declared internally in the '<...>' syntax, or derived by the 
  type checker.
  
  List types are treated differently. The are added as alternatives to the element type, such that an 
  arbitrary number of list variables can be elements of list patterns. To retrieve their original type, we store
  the list symbol as one of the attributes of the generated production.
  
  Another exception is made for lexicals. Since currently the type checker is not inline yet, we can not see at parse time
  which nonterminal names are lexical and which are not. Since nonterminal names are unique between lex and normal nonterminals
  we make sure that the literal that is generated is first normalized to remove all lex names.   

## function createHole {#lang-rascal-grammar-ConcreteSyntax-createHole}

* ``str createHole(ConcretePart hole, int idx)``
* ``str createHole(ConcreteHole hole, int idx)``

  This function is called by the Rascal interpreter to generate a string that can be parsed by the rules generated by the
  holes function in this module.

## function denormalize {#lang-rascal-grammar-ConcreteSyntax-denormalize}

* ``Symbol denormalize(Symbol s)``

  In Rascal programs with type literals, it's hard to see easily if it is a lex or sort, so we "denormalize" here.
  The same goes for the introduction of layout non-terminals in lists. We do not know which non-terminal is introduced,
  so we remove this here to create a canonical 'source-level' type.

## function getTargetSymbol {#lang-rascal-grammar-ConcreteSyntax-getTargetSymbol}

* ``Symbol getTargetSymbol(Symbol sym)``

This is needed such that list variables can be repeatedly used as elements of the same list

## function quotable {#lang-rascal-grammar-ConcreteSyntax-quotable}

* ``bool quotable(Symbol x)``

This decides for which part of the grammar we can write anti-quotes

