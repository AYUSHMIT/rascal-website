---
sidebar_position: 10
---

**Synopsis.**

All exceptions and errors a Rascal program can generate during execution (run time).

**Description.**

Rascal can generate various kinds of exceptions and errors during execution (run time):

  - [Runtime Exceptions](#RunTimeErrors-RuntimeExceptions) are discovered during execution of the Rascal program and can
    be caught by the Rascal program. When a runtime exception is not caught in the program, execution is aborted.

  - [Other Runtime Errors](#RunTimeErrors-OtherRuntimeErrors) are discovered during execution of the Rascal program and
    cannot be caught by the Rascal program. They always lead to abortion of execution. These are the errors which can be
    prevented by fixing statically detected errors by the type checker.

<!-- end list -->

  - The structure and naming of exceptions and error messages is being revised so actual exceptions may differ from what
    is presented here.

  - Since the type checker is not available yet, the interpreter throws more run-time exceptions than necessary.

# Runtime Exceptions

**Synopsis.**

All runtime exceptions that can occur during execution of a Rascal program.

**Description.**

The following exceptions can be trown as the result of a run-time error:

  - [Ambiguity](#RuntimeExceptions-Ambiguity): Ambiguity found in parsed text.

  - [Arithmetic Exception](#RuntimeExceptions-ArithmeticException): An arithmetic exception occurred.

  - [Assertion Failed](#RuntimeExceptions-AssertionFailed): An assertion in the Rascal code is false.

  - [Empty List](#RuntimeExceptions-EmptyList): Illegal operation on an empty list.

  - [Empty Map](#RuntimeExceptions-EmptyMap): Illegal operation on an empty map.

  - [Empty Set](#RuntimeExceptions-EmptySet): Illegal operation on an empty set.

  - [IO](#RuntimeExceptions-IO): An input/output operation caused an error.

  - [Index Out Of Bounds](#RuntimeExceptions-IndexOutOfBounds): Index is out of bounds.

  - [Invalid Argument](#RuntimeExceptions-InvalidArgument): A function or operation is applied to an invalid argument
    value.

  - [Invalid URI](#RuntimeExceptions-InvalidURI): An invalid URI is created at runtime.

  - [Invalid Use Of Date](#RuntimeExceptions-InvalidUseOfDate): Invalid of of a date at runtime.

  - [Invalid Use Of Location](#RuntimeExceptions-InvalidUseOfLocation): Invalid use of a source location at runtime.

  - [Invalid Use Of Time](#RuntimeExceptions-InvalidUseOfTime): Invalid use of a time value at runtime.

  - [Java](#RuntimeExceptions-Java): Runtime error generated by Java code.

  - [No Main Function](#RuntimeExceptions-NoMainFunction): Rascal program does not provide a `main` function.

  - [No Parent](#RuntimeExceptions-NoParent): Parent directory is missing in source location.

  - [No Such Annotation](#RuntimeExceptions-NoSuchAnnotation): Annotation without a value.

  - [No Such Field](#RuntimeExceptions-NoSuchField): Field of an abstract data type value cannot be found at runtime.

  - [No Such Key](#RuntimeExceptions-NoSuchKey): A map does not contain a requested key.

  - [Not Implemented](#RuntimeExceptions-NotImplemented): Attempt to execute an unimplemented feature.

  - [Parse Error](#RuntimeExceptions-ParseError): Parse of a syntactically incorrect string.

  - [RegExp Syntax Error](#RuntimeExceptions-RegExpSyntaxError): Syntax error in regular expression at run time.

  - [Unavailable Information](#RuntimeExceptions-UnavailableInformation): Requested information is unavailable at
    runtime.

## Ambiguity

**Synopsis.**

Ambiguity found in parsed text.

**Description.**

Rascal supports general context-free grammars and also provides various mechanisms to disambiguate them.

This exception is thrown when, given a grammar and a sentence, an ambiguity is found while parsing the sentence
according to that grammar.

**Examples.**

First declare a very simple expression language that should recognize expressions like `a`, `a+a`, `a+(a+a)`:

``` rascal-shell
syntax A = "a";
syntax E = A | "(" E ")" | E "+" E;
```

Next, import the ParseTree module that provides a `parse` function that we will use:

``` rascal-shell
import ParseTree;
```

Entering a first expression goes well, except that the parser generator already predicts future ambiguity. So it prints
a warning.

``` rascal-shell-error
parse(#E, "a+a");
```

The following example triggers the predicted ambiguity indeed:

``` rascal-shell
parse(#E, "a+a+a");
```

The conclusion is that there are two parses here: `a+(a+a)` and `(a+a)+a`, because we did forget to define the
associativity of the `+` operator.

Let’s fix this:

``` rascal-shell
syntax A = "a";
syntax E = A | "(" E ")" | left E "+" E;
import ParseTree;
parse(#E, "a+a+a");
```

However, one can also deal with ambiguity differently. For example we could have the parser build a tree for all
ambiguous interpretations and inspect the resulting data-structure:

``` rascal-shell
syntax A = "a";
syntax E = A | "(" E ")" | left E "+" E | left E "*" E;
import ParseTree;
t = parse(#E, "a+a*a", allowAmbiguity=true);
// Is the forest indeed ambiguous?
/amb(_) := t
// How many alternatives?
import Set;
import IO;
/amb(a) := t ? size(a) : 0;
// Which rules are at the top of the alternatives?
if (/amb({a1, a2}) := t)
  println("alternative 1: <a1.prod>
          'alternative 2: <a2.prod>");
```

Or, one could catch the ambiguity and report it like a [Parse Error](#RuntimeExceptions-ParseError):

``` rascal-shell
import IO;
try
  parse(#E, "a+a*a");
catch Ambiguity(loc l, str s, _):
  println("the input is ambiguous for <s> on line <l.begin.line>");
```

Here are some pointers for further disambiguation help:

  - [Syntax Definitions](/Rascal#Declarations-SyntaxDefinition).

  - [Disambiguation features](/Rascal#SyntaxDefinition-Disambiguation).

## Arithmetic Exception

**Synopsis.**

An arithmetic exception occurred.

**Types.**

`data RuntimeException = ArithmeticException(str message);`

**Usage.**

`import Exception;` (only needed when `ArithmeticException` is used in `catch`)

**Description.**

This error is generated when an illegal arithmetic operation occurs or when a numeric function is called with an
out-of-range argument.

Remedies:

  - Check the validity of the argument before you call the function or apply the operator.

  - Catch the `ArithmeticException` yourself, see [try catch](/Rascal#Statements-TryCatch) statement.

**Examples.**

Division by 0 gives an error:

``` rascal-shell
3/0;
```

Giving an out-of-range argument to a mathematical function also gives an error:

``` rascal-shell
import util::Math;
tan(-550000000000000000000000);
```

We can also catch the `ArithmeticException` error. First import the Rascal exceptions (which are also included in
`Prelude`) and `IO`:

``` rascal-shell
import Exception;
import IO;
try println(3/0); catch ArithmeticException(msg): println("The message is: <msg>");
```

## Assertion Failed

**Synopsis.**

An assertion in the Rascal code is false.

**Function.**

`data RuntimeException = AssertionFailed(str label);`

**Description.**

An [Assert](/Rascal#Assert) statement can be used to check assumptions during the execution of a Rascal program. This
error is generated if an assertion is not true.

Remedies:

  - Modify your code to make the assertion true.

  - Modify your assertion to reflect the current behaviour of your code.

  - Catch the `AssertionFailed` yourself, see [try catch](/Rascal#TryCatch).

**Examples.**

A false assertion gives an error:

``` rascal-shell
assert 3 > 4;
```

Define a function that only increments positive integers:

``` rascal-shell
int incrPositive(int n) { assert n > 0: "n should be greater than 0"; return n + 1; }
```

Calling it with a positive integer is fine:

``` rascal-shell
incrPositive(3);
```

But a negative argument gives an error:

``` rascal-shell
incrPositive(-3);
```

We can also catch the `AssertionFailed` error. First import the Rascal exceptions (which are also included in `Prelude`)
and `IO`:

``` rascal-shell
import Exception;
import IO;
try println(incrPositive(-3)); catch AssertionFailed(msg): println("incrPositive: <msg>");
```

  - Enables the precise expression of assumptions in your code.

  - Asserts are actually executed when the compiler option `enableAsserts` is set to true (by default set to `false`).

  - In the RascalShell, `enableAsserts` is always true.

## Empty List

**Synopsis.**

Illegal operation on an empty list.

**Types.**

`data RuntimeException = EmptyList();`

**Usage.**

`import Exception;` (only needed when `EmptyList` is used in `catch`)

**Description.**

Rascal provides many operations and functions on lists, see [list values](/Rascal#Values-List) and [list
functions](/Libraries#Prelude-List). This error is generated when a function or operation cannot handle the empty list.

Remedies:

  - Guard the function or operation with a test on the empty list ([isEmpty](/Libraries#List-isEmpty)) and take
    alternative action in that case.

  - Catch the `EmptyList` yourself, see [try catch](/Rascal#Statements-TryCatch).

**Examples.**

Import the `List` library and introduce `L` with an empty list as value:

``` rascal-shell
import List;
L = [];
```

Taking the head of an empty list gives an error:

``` rascal-shell
head(L);
```

This is the case when taking the tail as well:

``` rascal-shell
tail(L);
```

We can also catch the `EmptyList` error. First import the Rascal exceptions (which are also included in `Prelude`) and
`IO`:

``` rascal-shell
import Exception;
import IO;
try
  println(head(L));
catch EmptyList():
  println("Cannot take head of empty list");
```

## Empty Map

**Synopsis.**

Illegal operation on an empty map.

**Types.**

`data RuntimeException = EmptyMap();`

**Usage.**

`import Exception;` (only needed when `EmptyMap` is used in `catch`)

**Description.**

Rascal provides many operations and functions on maps, see [map values](/Rascal#Values-Map) and [map
functions](/Libraries#Prelude-Map). This error is generated when a function or operations cannot handle the empty map
case.

Remedies:

  - Guard the function or operation with a test on the empty map ([isEmpty](/Libraries#Map-isEmpty)) and take
    alternative action in that case.

  - Catch the `EmptyMap` yourself, see [try catch](/Rascal#Statements-TryCatch).

**Examples.**

Import the `Map` library and introduce `M` with an empty map as value:

``` rascal-shell
import Map;
M = ();
```

Trying to get an arbitrary value from it gives an error:

``` rascal-shell
getOneFrom(M);
```

We can also catch the `EmptyMap` error. First import the Rascal exceptions (which are also included in `Prelude`) and
`IO`:

``` rascal-shell
import Exception;
import IO;
try
  println(getOneFrom(M));
catch EmptyMap():
  println("Cannot use getOneFrom on empty map");
```

## Empty Set

**Synopsis.**

Illegal operation on an empty set.

**Types.**

`data RuntimeException = EmptySet();`

**Usage.**

`import Exception;` (only needed when `EmptySet` is used in `catch`)

**Description.**

Rascal provides many operations and functions on sets, see [set values](/Rascal#Values-Set) and [set
functions](/Libraries#Prelude-Set). This error is generated when a function or operations cannot handle the empty set.

Remedies:

  - Guard the function or operation with a test on the empty set ([isEmpty](/Libraries#Set-isEmpty)) and take
    alternative action in that case.

  - Catch the `EmptySet` yourself, see [try catch](/Rascal#Statements-TryCatch).

**Examples.**

Import the `Set` library and introduce `S` with an empty set as value:

``` rascal-shell
import Set;
S = {};
```

Taking an element from an empty set gives an error:

``` rascal-shell
getOneFrom(S);
```

We can also catch the `EmptySet` error. First import the Rascal exceptions (which are also included in `Prelude`) and
`IO`:

``` rascal-shell
import Exception;
import IO;
try
  println(getOneFrom(S));
catch EmptySet():
  println("Cannot apply getOneFrom to empty set");
```

## IO

**Synopsis.**

An input/output operation caused an error.

**Types.**

`data RuntimeException = IO(str message);`

**Usage.**

`import Exception;` (only needed when `IO` is used in `catch`)

**Description.**

This error can be generated for many reasons.

First there may be a problem in the [location](/Rascal#Values-Location) that is used. It maybe that the *schemes* is not
supported. Examples of supported schemes include `http`, `file`, `home`, `std`, `rascal` and `project`. It can also be
the case that the *host* that occurs in the location cannot be found.

Second, while trying to open the file things can go wrong like insufficient access rights

Finally, actual reading or writing can fail (device failure, device full, and the like).

Remedies:

  - Check for any errors in the location you are using.

  - Check that you are allowed to read or write the resource indicated by the location.

  - Catch `IO` using a [try catch](/Rascal#Statements-TryCatch).

**Examples.**

Import the `IO` library and attempt to use a non-existing scheme:

``` rascal-shell
import IO;
readFile(|myScheme:///example.rsc|);
```

We can catch this `IO` error. First import the Rascal exceptions (which are also included in `Prelude`):

``` rascal-shell
import Exception;
try
  readFileLines(|myScheme:///example.rsc|);
catch IO(msg):
  println("This did not work: <msg>");
```

## Index Out Of Bounds

**Synopsis.**

Index is out of bounds.

**Types.**

`data RuntimeException = IndexOutOfBounds(int index)`

**Usage.**

`import Exception;` (only needed when `IndexOutOfBounds` is used in `catch`)

**Description.**

Subscription is possible on various ordered types, including [list](/Rascal#List-Subscription),
[tuple]({RascaLangl}#Tuple-Subscription), and [node](/Rascal#Node-Subscription). This error is generated when a
subscript is out of bounds for the value that is being subscripted.

Remedies:

  - Guard the subscription with a test that the index is within bounds.

  - Make your code less dependent on index values. Suggestions:
    
      - Use the [index](/Libraries#List-index) to produce all legal indices of a list. Instead of `for(int i ←
        [0..size(L)]) { …​ }` use `for(int i ← index(L)) { …​ }`.
    
      - Use a [list slice](/Rascal#List-Slice) to automate part of the index computation.

  - Catch the `IndexOutOfBounds` yourself, see [try catch](/Rascal#Statements-TryCatch).

**Examples.**

Initialize a list `L`:

``` rascal-shell
L = [0, 10, 20, 30, 40];
```

The legal indices are 0, 1, 2, 3, 4, so index 5 gives an error:

``` rascal-shell
L[5];
```

We can catch the `IndexOutOfBounds` error. First import the Rascal exceptions (which are also included in `Prelude`) and
`IO`:

``` rascal-shell
import Exception;
import IO;
try
  L[5];
catch IndexOutOfBounds(msg):
  println("The message is: <msg>");
```

## Invalid Argument

**Synopsis.**

A function or operation is applied to an invalid argument value.

**Types.**

`data RuntimeException = InvalidArgument() | InvalidArgument(value v) | InvalidArgument(value v, str message);`

**Usage.**

`import Exception;` (only needed when `InvalidArgument` is used in `catch`)

**Description.**

This error is generated when a function or operation is applied to a value that it does not expect.

Remedies:

  - Check the value or values to which you apply the function or operation.

**Examples.**

Changing the month of a [DateTime](/Rascal#Values-DateTime) to an illegal month (13):

``` rascal-shell
NOW = $2013-01-13T22:16:51.740+01:00$;
NOW.month = 13;
```

Setting the offset in a location to a negative value:

``` rascal-shell
someLoc = |home:///abc.txt|;
someLoc.offset = -1;
```

## Invalid URI

**Synopsis.**

An invalid URI is created at runtime.

**Types.**

`data RuntimeException = InvalidURI(str uri);`

**Usage.**

`import Exception;` (only needed when `InvalidURI` is used in `catch`)

**Description.**

Thrown by operations on [source locations](/Rascal#Values-Location) that would lead to an invalid URI part of a source
location value.

**Examples.**

``` rascal-shell
someLoc = |home:///abc.txt|;
someLoc.scheme = "a:b";
```

Another well-known example is a missing path when using `//` (wrong) instead of `///` (good):

``` rascal-shell
|home:///|;
|home://|;
```

## Invalid Use Of Date

**Synopsis.**

Invalid of of a date at runtime

**Types.**

`data RuntimeException = InvalidUseOfDate(str message);`

**Usage.**

`import Exception;` (only needed when `InvalidUseOfDate` is used in `catch`)

**Description.**

Thrown by operations on date values that try to update unavailable information.

**Examples.**

Setting the `hour` field on a date value throws an exception:

``` rascal-shell
NOW = $2016-09-18$;
NOW.hour = 14;
```

> **Note**
> 
> Exception is not shown properly

## Invalid Use Of Location

**Synopsis.**

Invalid use of a source location at runtime.

**Types.**

`data RuntimeException = InvalidUseOfLocation(str message);`

**Usage.**

`import Exception;` (only needed when `InvalidUseOfLocation` is used in `catch`)

**Description.**

Thrown by operations on [source locations](/Rascal#Values-Location) that would lead to an inconsistent or incomplete
location value.

**Examples.**

``` rascal-shell
someLoc = |home:///abc.txt|;
someLoc.begin = <1, 2>;
```

## Invalid Use Of Time

**Synopsis.**

Invalid use of a time value at runtime

**Types.**

`data RuntimeException = InvalidUseOfTime(str message);`

**Usage.**

`import Exception;` (only needed when `InvalidUseOfTime` is used in `catch`)

**Description.**

Thrown by operations on time values that try to update unavailable information.

**Examples.**

Setting the `year` field on a time value throws an exception:

``` rascal-shell
NOW = $T20:11:01.463+00:00$;
NOW.year = 2020;
```

> **Note**
> 
> Exception is not shown properly

## Java

**Synopsis.**

Runtime error generated by Java code.

**Description.**

This error is generated when an unexpected Java execption is thrown in the Rascal implementation.

Remedy: Contact the Rascal developers:

  - Ask a question at <http://stackoverflow.com/questions/tagged/rascal>.

  - Read the currently open issues at the Rascal’s issue tracker at
    <https://github.com/cwi-swat/rascal/issues?state=open>. If your problem has not yet been reported by someone else,
    please report it here.

If you are an expert developer and have implemented your own extension in Java, please check your own extension code
first.

## No Main Function

**Synopsis.**

Rascal program does not provide a `main` function.

**Types.**

`data RuntimeException = NoMainFunction(str message);`

**Usage.**

`import Exception;` (only needed when `NoMainFunction` is used in `catch`)

**Description.**

Thrown when executing a Rascal program that does not declare a main function.

## No Parent

**Synopsis.**

Parent directory is missing in source location.

**Types.**

`data RuntimeException = NoParent(loc noparentloc);`

**Usage.**

`import Exception;` (only needed when `NoParent` is used in `catch`)

## No Such Annotation

**Synopsis.**

Annotation without a value.

**Types.**

`data RuntimeException = NoSuchAnnotation(str label);`

**Usage.**

`import Exception;` (only needed when `NoSuchAnnotation` is used in `catch`)

**Description.**

An [annotation](/Rascal#Declarations-Annotation) can be associated with any node value (including any [algebraic data
type](/Rascal#Declarations-AlgebraicDataType)). This error is generated when the value of an annotation is requested but
has not been defined.

Remedies:

  - Ensure that the annotation value is properly initialized for all relevant parts of the node value.

  - Use the [isDefined](/Rascal#Boolean-isDefined) and [ifDefinedElse](/Rascal#Boolean-ifDefinedElse) operators to check
    whether the annotation value is set and act accordingly.

  - Catch the `NoSuchAnnotation yourself`, see [try catch](/Rascal#Statements-TryCatch).

**Examples.**

INFO: Eliminate the double Error: Error:

``` rascal-shell
data Fruit = apple(int n) | orange(int n);
anno str Fruit @ quality;
piece = orange(13);
piece@quality;
```

Use the unary postfix operator isDefined `?` to check whether the `quality` annotation is set:

``` rascal-shell
piece@quality?;
```

Use the ternary operator ifDefinedElse `?` to compute an alternative value when the `quality` annotation is not set:

``` rascal-shell
piece@quality ? "no quality value";
```

We can also catch the `NoSuchAnnotation` error. First import the Rascal exceptions (which are also included in
`Prelude`) and `IO`:

``` rascal-shell
import Exception;
import IO;
try piece@quality; catch NoSuchAnnotation(l): println("No such annotation: <l>");
```

Finally, we can just assign a value to the `quality` annotation:

``` rascal-shell
piece@quality = "excellent";
piece@quality;
```

> **Warning**
> 
> Using white space around the `@` confuses the Rascal parser

## No Such Field

**Synopsis.**

Field of an abstract data type value cannot be found at runtime.

**Types.**

`data RuntimeException = NoSuchField(str name);`

**Usage.**

`import Exception;` (only needed when `NoSuchField` is used in `catch`)

**Description.**

Selecting a field from an abstract datatype depends on the actual constructor being used at run time. This exception is
thrown when a non-existent field is accessed.

**Examples.**

Consider this highly simplified view on persons:

``` rascal-shell
data Person = man(str name, bool beard) | woman(str name, bool necklace);
jane = woman("jane", false);
```

The field `beard` is evidently only applicable to a `man` but not to a woman (didn’t we say "simplified", above):

``` rascal-shell
jane.beard;
```

## No Such Key

**Synopsis.**

A map does not contain a requested key.

**Types.**

`data RuntimeException = NoSuchKey(value v);`

**Usage.**

`import Exception;` (only needed when `NoSuchKey` is used in `catch`)

**Description.**

Rascal provides many operations and functions on maps, see [map values](/Rascal#Values-Map) and [map
functions](/Libraries#Prelude-Map). This error is generated when a function or operation cannot find a requested key
value in a map.

Remedies:

  - Use the [isDefined](/Rascal#Boolean-isDefined) and [ifDefinedElse](/Rascal#Boolean-ifDefinedElse) operator to guard
    a lookup in a map.

  - Catch the `NoSuchKey` yourself, see [try catch](/Rascal#Statements-TryCatch).

**Examples.**

Import the `Map` and `IO` libraries and introduce map `M`:

``` rascal-shell
import Map;
import IO;
M = ("a" : 1, "b" : 2);
```

Indexing `M` with a non-existing key gives an error:

``` rascal-shell
M["c"]
```

Use the postfix isDefined operator `?` to test whether the value is defined:

``` rascal-shell
if(M["c"]?) println("defined"); else println("not defined");
```

Or use the binary ifDefinedElse operator `?` to return an alternative value when the value of `M["c"]` is undefined:

``` rascal-shell
M["c"] ? 3
```

Yet another solution is to use try/catch. First we import the Rascal exceptions (which are also included in `Prelude`):

``` rascal-shell
import Exception;
try println(M["c"]); catch NoSuchKey(k): println("Key <k> does not exist");
```

## Not Implemented

**Synopsis.**

Attempt to execute an unimplemented feature.

**Types.**

`data RuntimeException = NotImplemented(str msg), loc src);`

**Usage.**

`import Exception;` (only needed when `NotImplemented` is used in `catch`)

**Description.**

Thrown when a not (yet) implemented feature is executed. This exception is mostly used by the Rascal implementors.

## Parse Error

**Synopsis.**

Parse of a syntactically incorrect string.

**Types.**

`data RuntimeException = ParseError(loc parseloc) | ParseError(loc parseloc, str nt, str s);`

**Usage.**

`import Exception;` (only needed when `ParseError` is used in `catch`)

**Description.**

This error is generated when during the execution of a Rascal program the [parse](/Libraries#ParseTree-parse) function
is applied to a syntactically incorrect input sentence.

Remedies:

  - Correct the input sentence.

  - Adapt the grammar so that it accepts the input sentence.

  - Catch the ParseError yourself, see [try catch](/Rascal#Statements-TryCatch).

**Examples.**

Define the non-terminal `As` that accepts one or more letters `a`:

``` rascal-shell
syntax As = "a"+;
```

Then import `ParseTree` so that we can use the `parse` function:

``` rascal-shell
import ParseTree;
```

Now we can parse sentences consisting of letters `a`:

``` rascal-shell
parse(#As, "aaaaaaaa");
```

But we get an error when parsing syntactically incorrect input (i.e., that does not consists of letters `a` only):

``` rascal-shell
parse(#As, "aaaabaaa");
```

We can also catch the ParseError but first import the Rascal modules `Exception` and `IO`:

``` rascal-shell
import Exception;
import IO;
try
  parse(#As, "aaaabaaa");
catch ParseError(e):
  println("Your input cannot be parsed: <e>");
```

## RegExp Syntax Error

**Synopsis.**

Syntax error in regular expression at run time

**Types.**

`data RuntimeException = RegExpSyntaxError(str message);`

**Usage.**

`import Exception;` (only needed when `RegExpSyntaxError` is used in `catch`)

**Description.**

At the moment, the parsing and compilation of regular expression is done at run time. This exception is thrown when a
syntactically incorrect regular expression is used.

**Examples.**

The following regular expression `/+/` is incorrect (maybe `/a+/` was meant?):

``` rascal-shell
/+/ := "aaaa";
```

## Unavailable Information

**Synopsis.**

Requested information is unavailable at runtime

**Types.**

`data RuntimeException = UnavailableInformation(str message);`

**Usage.**

`import Exception;` (only needed when `UnavailableInformation` is used in `catch`)

**Description.**

Several datetypes may contain optional information that is not always available:

  - In a [datetime](/Rascal#Values-DateTime) value the date or the time may be missing.

  - In a [location](/Rascal#Values-Location) value, various fields are optional, e.g., `port`, `offset`, `begin` and
    `end`.

This exception is thrown when optional information is not available.

**Examples.**

``` rascal-shell
$2016-09-14$.hour;
someLoc = |home:///abc.txt|;
someLoc.offset;
```

# Other Runtime Errors

**Synopsis.**

Other runtime errors that cannot be caught as a runtime exception.

**Description.**

Note: Examples will be collected here

## Compiler Error

**Synopsis.**

An internal error in the Rascal compiler

**Description.**

An internal error condition occurred while running the Rascal compiler. This exception may be generated due to:

  - An actual internal inconsistency.

  - Incorrect information as computed by the type checker.

  - Incorrect configuration of paths (PathConfig) when calling the compiler.

  - Causes outside control of the compiler.

**Pitfalls.**

At the moment this error category is too wide and should be narrowed.
