[[Values-Set]]
# Set
:concept: Expressions/Values/Set

.Synopsis
Set values.

.Syntax
`{ _Exp_~1~, _Exp~2~_, ... }`

.Usage

.Types


|====
|  `_Exp~1~_` |  `_Exp~2~_` |  ...  |  `{ _Exp~1~_, _Exp~2~_, ... }`   

| _T~1~_    | _T~2~_    |  ...  |  set[ lub(_T~1~_, _T~2~_, ... ) ] 
|====

.Function

.Description
A set is an unordered sequence of values and has the following properties:

*  All elements have the same static type.
*  The order of the elements does not matter.
*  A set contains an element only once. In other words, duplicate elements are eliminated and no 
  matter how many times an element is added to a set, it will occur in it only once.


The type of a set has the form `set[_T_]`,
where `_T_` is an arbitrary type.

When a value or variable of type set occurs inside a set, that set value is inserted as set element. 
To achieve splicing of these elements, i.e., the insertion of the elements of the set value rather than the whole set,
it has to be prefixed by the splice operator `*`.

The following operators are provided on sets:

**** <<Set-Comprehension,Set Comprehension>>: A set comprehension generates a set value.
**** <<Set-Difference,Set Difference>>: The difference between two sets.
**** <<Set-Equal,Set Equal>>: Equal operator on set values.
**** <<Set-Insert,Set Insert>>: Add an element to a set.
**** <<Set-Intersection,Set Intersection>>: Intersection of two sets.
**** <<Set-NotEqual,Set NotEqual>>: Not equal operator on set values.
**** <<Set-Product,Set Product>>: The product of two set values.
**** <<Set-Splice,Set Splice>>: Splice the elements of a set in an enclosing set.
**** <<Set-StrictSubSet,Set StrictSubSet>>: Strict subset operator on set values.
**** <<Set-StrictSuperSet,Set StrictSuperSet>>: Strict superset operator on set values.
**** <<Set-SubSet,Set SubSet>>: Subset operator on set values.
**** <<Set-SuperSet,Set SuperSet>>: Superset operator on set values.
**** <<Set-Union,Set Union>>: Union of two set values.
**** <<Set-in,Set in>>: Membership test on set values.
**** <<Set-notin,Set notin>>: Negated membership test on set values.

The following functions are provided on sets:
subtoc[Rascal/Libraries/Prelude/Set,1]

.Examples
##  Set types 

[source,rascal-shell]
----
rascal>{1, 2, 3};
set[int]: {1,3,2}
rascal>{<1,10>, <2,20>, <3,30>};
rel[int,int]: {
  <1,10>,
  <2,20>,
  <3,30>
}
rascal>{1, "b", 3};
set[value]: {"b",1,3}
rascal>{<"a", 10>, <"b", 20>, <"c", 30>}
rel[str,int]: {
  <"b",20>,
  <"a",10>,
  <"c",30>
}
rascal>{{"a", "b"}, {"c", "d", "e"}}
set[set[str]]: {
  {"a","b"},
  {"c","d","e"}
}
----
Note that

*  `{1, 2, 3}` and `{3, 2, 1}` are identical sets (since order is not relevant).
*  `{1, 2, 3}` and `{1, 2, 3, 1}` are also identical sets (since duplication is not relevant).



##  Set splicing 

Introduce a set variable `S`
[source,rascal-shell]
----
rascal>S = {1, 2, 3};
set[int]: {1,3,2}
----
and observe how the value of `S` is added as single element in another set:
[source,rascal-shell]
----
rascal>{10, S, 20};
set[value]: {10,20,{1,3,2}}
----
or how its elements are added as elements to the other set:
[source,rascal-shell]
----
rascal>{10, *S, 20};
set[int]: {10,1,3,20,2}
----

.Benefits

.Pitfalls


:leveloffset: +1
include::Comprehension/Comprehension.adoc[Comprehension]

include::Difference/Difference.adoc[Difference]

include::Equal/Equal.adoc[Equal]

include::Insert/Insert.adoc[Insert]

include::Intersection/Intersection.adoc[Intersection]

include::NotEqual/NotEqual.adoc[NotEqual]

include::Product/Product.adoc[Product]

include::Splice/Splice.adoc[Splice]

include::StrictSubSet/StrictSubSet.adoc[StrictSubSet]

include::StrictSuperSet/StrictSuperSet.adoc[StrictSuperSet]

include::SubSet/SubSet.adoc[SubSet]

include::SuperSet/SuperSet.adoc[SuperSet]

include::Union/Union.adoc[Union]

include::in/in.adoc[in]

include::notin/notin.adoc[notin]


:leveloffset: -1